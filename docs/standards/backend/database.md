---
layout: default
title: Database
permalink: /standards/backend/database
parent: Backend
grand_parent: Standards
nav_order: 4
---

# Database

## Why

Naming conventions are important in a database and in application development in general. Having clear, concise names for tables, procedures, etc., is important for many reasons. It makes searching for the relevant table easier. It is more intuitive for someone learning the system.

## Database Convetion
### Common Conventions
- Table name should have plural name.
- Both tables and columns should use lower case :), with underscores. These are very readable and cross platform.
- Each table in the database must have a timestamp column for created_at and/or updated_at, deleted_at for soft delete
  - for date type, it is recommended to use zoned date time (timestamp with timezone)
- Each table in the database it is recommended to add created_by, updated_by, and/or deleted_by
- Foreign key should have table name as prefix

### Tables convention:
- Use a collective name. For example staff and employees.
- Do not prefix with tbl or any other such descriptive prefix or Hungarian notation.
- Never give a table the same name as one of its columns and vice versa. 
- It is recommended to avoid, where possible, concatenating two table names together to create the name of a relationship table. Rather than cars_mechanics prefer services.

### Columns convention:
- Always use the singular name.
- Do not add a column with the same name as its table and vice versa.
- Always use lowercase except where it may make sense not to such as proper nouns.
- For boolean column type, use 'is_' prefix. Example: is_active, is_used.
- Avoid boolean/number for multiple status column. Example: order status, rather than 1 (pending), 2 (paid), 3 (complete), use ENUM 'pending', 'paid', or 'complete'.


## Database Flow Tips
- EXPLAIN Your SELECT Queries.

Using the EXPLAIN keyword can give you insight on what MySQL is doing to execute your query
{: .fs-2 }

- Things that need attention in query that may slowing the performance:
  - Sub query
  - SUM query
  - Avoid select *, all columns name should written explicitly
  - Use wrong data type, for example use VARCHAR over ENUM when field will contain only a few different kinds of values. ENUM type columns are very fast and compact. Internally they are stored like TINYINT

The more data is read from the tables, the slower the query will become. It increases the time it takes for the disk operations. Also when the database server is separate from the web server, you will have longer network delays due to the data having to be transferred between the servers.
{: .fs-2 }

- Add Index to key columns
  - Make sure to index the columns which are used in JOIN clauses so that the query returns the result fast. 
  - If you use UPDATE statement that involves more than one table make sure that all the columns which are used to join the tables are indexed
- Count data should be implemented at the database level, rather than application level.
- Insert query should use TRANSACTION, so if one of the processes is failed, all insert processes can be rolled back. 
- Should make sure to use production environment when do migration and seed and make sure the seed process won't be truncate the table data 
- Make sure developer has the right access so the developer won't drop database or truncate it 
- Choose proper Database Engine: 
  - If you develop an application that reads data more often than writing (ex: search engine), choose MyISAM storage engine. 
  - If you develop an application that writes data more often than reading (ex: real-time bank transactions), choose INNODB storage engine. 
- LIMIT 1 When Getting a Unique Row. 

In such cases, adding LIMIT 1 to your query can increase performance. This way the database engine will stop scanning for records after it finds just 1, instead of going thru the whole table or index
{: .fs-2 }

- Recommend to split the Big DELETE or INSERT Queries 

If you end up locking your tables for any extended period of time (like 30 seconds or more), on a high traffic web site, you will cause a process and query pileup, which might take a long time to clear or even crash your web server. 
{: .fs-2 }

If you have some kind of maintenance script that needs to delete large numbers of rows, just use the LIMIT clause to do it in smaller batches to avoid this congestion.
{: .fs-2 }

- Always check the query generated by ORM. There are many cases that query is not optimal by ORM. Please check with EXPLAIN. Watch EXECUTION TIME properly. 
- WARNING, using association query generated by ORM may impact performance. ALWAYS check execution time query using associations. 
- Wrap your query inside CACHE. Cache 1 min will help performance.


